import { create } from 'zustand';
import { persist } from 'zustand/middleware';

const useStore = create(
    persist(
        (set, get) => ({
            // --- User Profile ---
            username: 'User',
            setUsername: (name) => set({ username: name }),

            // --- User Stats ---
            streak: 0,
            lastCompletionDate: null,

            updateStreak: () => set((state) => {
                const today = new Date().toDateString();
                const lastDate = state.lastCompletionDate;

                if (!lastDate) {
                    return { streak: 1, lastCompletionDate: today };
                }

                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);

                if (lastDate === today) {
                    return state; // Already counted today
                } else if (lastDate === yesterday.toDateString()) {
                    return { streak: state.streak + 1, lastCompletionDate: today };
                } else {
                    return { streak: 1, lastCompletionDate: today };
                }
            }),

            // --- Tasks ---
            tasks: [],

            addTask: (task) => set((state) => {
                const newTask = {
                    ...task,
                    id: task.id || Date.now().toString(),
                    createdAt: task.createdAt || new Date().toISOString(),
                    completedAt: null,
                    priority: task.priority || 'medium',
                    tags: task.tags || [],
                    subtasks: task.subtasks || [],
                    attachments: task.attachments || [],
                    recurring: task.recurring || null,
                    dependsOn: task.dependsOn || [],
                    status: task.status || 'todo',
                    completed: false,
                };
                return { tasks: [newTask, ...state.tasks] };
            }),

            updateTask: (updatedTask) => set((state) => ({
                tasks: state.tasks.map((t) =>
                    t.id === updatedTask.id ? { ...t, ...updatedTask } : t
                ),
            })),

            deleteTask: (id) => set((state) => ({
                tasks: state.tasks.filter((t) => t.id !== id),
            })),

            moveTask: (id, newStatus) => set((state) => ({
                tasks: state.tasks.map((t) =>
                    t.id === id ? { ...t, status: newStatus } : t
                ),
            })),

            completeTask: (id) => set((state) => {
                const task = state.tasks.find(t => t.id === id);
                if (!task) return state;

                // Toggle completion status
                const isCompleting = !task.completed;

                const updatedTasks = state.tasks.map((t) =>
                    t.id === id
                        ? {
                            ...t,
                            completed: isCompleting,
                            completedAt: isCompleting ? new Date().toISOString() : null,
                            status: isCompleting ? 'done' : 'todo'
                        }
                        : t
                );

                // Update streak only when completing (not uncompleting)
                if (isCompleting) {
                    const today = new Date().toDateString();
                    const lastDate = state.lastCompletionDate;
                    let newStreak = state.streak;

                    if (!lastDate) {
                        newStreak = 1;
                    } else if (lastDate !== today) {
                        const yesterday = new Date();
                        yesterday.setDate(yesterday.getDate() - 1);
                        newStreak = lastDate === yesterday.toDateString() ? state.streak + 1 : 1;
                    }

                    return {
                        tasks: updatedTasks,
                        streak: newStreak,
                        lastCompletionDate: today,
                    };
                }

                return { tasks: updatedTasks };
            }),

            // --- Subtask Operations ---
            addSubtask: (taskId, subtask) => set((state) => ({
                tasks: state.tasks.map((t) =>
                    t.id === taskId
                        ? {
                            ...t,
                            subtasks: [...t.subtasks, {
                                id: Date.now().toString(),
                                title: subtask.title,
                                completed: false
                            }]
                        }
                        : t
                ),
            })),

            toggleSubtask: (taskId, subtaskId) => set((state) => ({
                tasks: state.tasks.map((t) =>
                    t.id === taskId
                        ? {
                            ...t,
                            subtasks: t.subtasks.map(st =>
                                st.id === subtaskId ? { ...st, completed: !st.completed } : st
                            )
                        }
                        : t
                ),
            })),

            deleteSubtask: (taskId, subtaskId) => set((state) => ({
                tasks: state.tasks.map((t) =>
                    t.id === taskId
                        ? { ...t, subtasks: t.subtasks.filter(st => st.id !== subtaskId) }
                        : t
                ),
            })),

            // --- Priority & Tags ---
            updateTaskPriority: (taskId, priority) => set((state) => ({
                tasks: state.tasks.map((t) =>
                    t.id === taskId ? { ...t, priority } : t
                ),
            })),

            addTaskTag: (taskId, tag) => set((state) => ({
                tasks: state.tasks.map((t) =>
                    t.id === taskId && !t.tags.includes(tag)
                        ? { ...t, tags: [...t.tags, tag] }
                mode: 'dark',
                    accentColor: 'holo-500',
                    variant: 'default',
            },

                setTheme: (theme) => set({ theme }),

                // --- Focus Mode ---
                isFocusMode: false,
                activeTaskId: null,
                setFocusMode: (isActive, taskId = null) => set({
                    isFocusMode: isActive,
                    activeTaskId: taskId
                }),

                // --- Helpers ---
                getFilteredTasks: () => {
                    const state = get();
                    let filtered = state.tasks.filter(t => !t.archived);

                    // Apply filters
                    const { priorities, tags, categories, status } = state.activeFilters;

                    if (priorities.length > 0) {
                        filtered = filtered.filter(t => priorities.includes(t.priority));
                    }

                    if (tags.length > 0) {
                        filtered = filtered.filter(t =>
                            t.tags.some(tag => tags.includes(tag))
                        );
                    }

                    if (categories.length > 0) {
                        filtered = filtered.filter(t => categories.includes(t.category));
                    }

                    if (status.length > 0) {
                        filtered = filtered.filter(t => status.includes(t.status));
                    }

                    // Apply search
                    if (state.searchQuery) {
                        const query = state.searchQuery.toLowerCase();
                        filtered = filtered.filter(t =>
                            t.title.toLowerCase().includes(query) ||
                            (t.description && t.description.toLowerCase().includes(query)) ||
                            t.tags.some(tag => tag.toLowerCase().includes(query))
                        );
                    }

                    // Apply sorting
                    filtered.sort((a, b) => {
                        let aVal = a[state.sortBy];
                        let bVal = b[state.sortBy];

                        if (state.sortBy === 'priority') {
                            const priorityOrder = { high: 3, medium: 2, low: 1 };
                            aVal = priorityOrder[a.priority];
                            bVal = priorityOrder[b.priority];
                        }

                        if (aVal < bVal) return state.sortOrder === 'asc' ? -1 : 1;
                        if (aVal > bVal) return state.sortOrder === 'asc' ? 1 : -1;
                        return 0;
                    });

                    return filtered;
                },
        }),
        {
            name: 'flow-storage',
        }
    )
);

export default useStore;
